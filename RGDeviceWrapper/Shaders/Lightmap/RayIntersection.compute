#include <StdInclude.h>
#include "autoBinder.h"

#deifne LIGHTMAP_STATE_IDLE		0
#define LIGHTMAP_STATE_SCATTER	(1*0x00000100)
#define LIGHTMAP_STATE_THROUGH	(2*0x00000100)
#define LIGHTMAP_STATE_CHILDBOX	(3*0x00000100)
#define LIGHTMAP_STATE_NEXTBOX	(4*0x00000100)
#define LIGHTMAP_STATE_TREADEND	(5*0x00000100)

#define CURR_BOX		g_Indicies[0].x
#define CURR_HARMONIC	g_Indicies[0].y
#define CURR_SAMPLE		g_Indicies[0].z
#define MAX_SAMPLE		g_Indicies[0].w
#define LIGHT_OFFSET	g_Indicies[1].x
#define NEXT_BOX		g_Indicies[1].y
#define NEXT_HARMONIC	g_Indicies[1].z
#define VALID_THREAD	g_Indicies[1].w

#define EDGE_THREASHOLD 0.1
#define NEIGHBOR_INDEX(x, y, z) (9*z+3*y+x)
#define NP 0
#define ZP 1
#define PP 2

void assignResult(LightmapIntersectResult a_Res)
{
	/* deocde
	float x = a_Res.m_OriginNormal.x;
    float y = a_Res.m_OriginNormal.y;
    float z = a_Res.m_OriginNormal.z;
    float x2 = x*x;
    float y2 = y*y;
    float z2 = z*z;

	basis[0]  = 1.0 / 2.0 * sqrt(1.0 / MATH_PI);
    basis[1]  = sqrt(3.0 / (4.0 * MATH_PI))*z;
    basis[2]  = sqrt(3.0 / (4.0 * MATH_PI))*y;
    basis[3]  = sqrt(3.0 / (4.0 * MATH_PI))*x;
    basis[4]  = 1.0 / 2.0 * sqrt(15.0 / MATH_PI) * x * z;
    basis[5]  = 1.0 / 2.0 * sqrt(15.0 / MATH_PI) * z * y;
    basis[6]  = 1.0 / 4.0 * sqrt(5.0 / MATH_PI) * (-x*x - z*z + 2 * y*y);
    basis[7]  = 1.0 / 2.0 * sqrt(15.0 / MATH_PI) * y * x;
    basis[8]  = 1.0 / 4.0 * sqrt(15.0 / MATH_PI) * (x*x - z*z);
    basis[9]  = 1.0 / 4.0 * sqrt(35.0 / (2.f*MATH_PI))*(3 * x2 - z2)*z;
    basis[10] = 1.0 / 2.0 * sqrt(105.0 / MATH_PI)*x*z*y;
    basis[11] = 1.0 / 4.0 * sqrt(21.0 / (2.f * MATH_PI))*z*(4 * y2 - x2 - z2);
    basis[12] = 1.0 / 4.0 * sqrt(7.0 / MATH_PI)*y*(2 * y2 - 3 * x2 - 3 * z2);
    basis[13] = 1.0 / 4.0 * sqrt(21.0 / (2.f * MATH_PI))*x*(4 * y2 - x2 - z2);
    basis[14] = 1.0 / 4.0 * sqrt(105.0 / MATH_PI)*(x2 - z2)*y;
    basis[15] = 1.0 / 4.0 * sqrt(35.0 / (2 * MATH_PI))*(x2 - 3 * z2)*x;

	vec3 c = vec3(0,0,0);
    for (int i = 0; i < 16; i++)
    {
        c += coef[i] * basis[i];
    }
    
    FragColor = vec4(c, 1);

	// encode
	double weight =4.0 * PI;
    for(int i=0; i<n_samples; ++i) 
    {
        for(int n=0; n<n_coeff; ++n)
        {
        result[n] += lightColor * samples[i].SH_basis_coeff[n];
        }
    }
    double factor = weight / n_samples;
    for(i=0; i<n_coeff; ++i)
    {
        result[i] = result[i] * factor;
    }
	*/
}

[numthreads(16, 1, 1 )]
void main(uint3 a_ThreadID : SV_DispatchThreadID)
{
	LightmapIntersectResult l_Res = g_Result[a_ThreadID.x];
	LightmapBoxCache l_Box = (LightmapBoxCache)0;
	switch( l_Res.m_StateDepth & 0xffffff00 )
	{
		case LIGHTMAP_STATE_IDLE:{
			int l_RayID = 0;
			InterlockedAdd(CURR_SAMPLE, 1, l_RayID);
			bool l_bUseNext = l_RayID >= MAX_SAMPLE;
			if( l_bUseNext )
			{
				if( 0 > NEXT_HARMONIC )
				{
					l_Res.m_StateDepth = LIGHTMAP_STATE_TREADEND;
					g_Result[a_ThreadID.x] = l_Res;
					InterlockedAdd(VALID_THREAD, -1);
					return;
				}

				l_RayID -= MAX_SAMPLE;
				l_Res.m_HarmonicsID = NEXT_HARMONIC;
			}
			else l_Res.m_HarmonicsID = CURR_HARMONIC;

			l_Res.m_StateDepth = 0;
			l_Res.m_Color = float3(1.0, 1.0, 1.0);
			l_Res.m_Emissive = float3(0.0, 0.0, 0.0);
			l_Res.m_TriangleIdx = -1;
			l_Res.m_CurrBoxID = l_bUseNext ? NEXT_BOX : CURR_BOX;

			l_Box = g_Box[l_Res.m_CurrBoxID];
			l_Res.m_RayOrigin = l_Box.m_BoxCenter;
			
			int3 l_BoxIdx;
			for( uint i=0 ; i<64 ; ++i )
			{
				if( l_Box.m_SHResult[i/4][i%4] != l_Res.m_HarmonicsID ) continue;

				l_BoxIdx.z = i / 16;
				l_BoxIdx.y = (i / 4) % 4;
				l_BoxIdx.x = i % 4;
				break;
			}

			const float c_Sub[4] = {-0.375, -0.125, 0.125, 0.375};
			l_Res.m_RayOrigin += l_Box.m_BoxSize * float3(c_Sub[l_BoxIdx.x], c_Sub[l_BoxIdx.y], c_Sub[l_BoxIdx.z]);

			float l_Quad = sqrt(MAX_SAMPLE);
			float l_Phi = a_ThreadID.x / l_Quad;
			float l_Theta = floor(l_Phi) / l_Quad;
			l_Phi = frac(l_Phi);

			l_Theta = acos(1.0 - 2.0 * l_Theta);
			l_Phi = 2.0 * MATH_PI * l_Phi;

			l_Res.m_RayDir = normalize(float3(cos(l_Theta) * sin(l_Phi), cos(l_Theta) * cos(l_Phi), sin(l_Theta)));
			}break;

		case LIGHTMAP_STATE_TREADEND: return;

		case LIGHTMAP_STATE_CHILDBOX:{
			l_Box = g_Box[l_Res.m_CurrBoxID];

			float l_Min = FLT_MAX;
			bool l_bFoundMinBox = false;
			bool l_bLeaf = true;
			for( int i=0 ; i<8 ; ++i )
			{
				if( -1 == l_Box.m_Children[i] ) continue;
				l_bLeaf = false;

				LightmapBoxCache l_ChildBox = g_Box[l_Box.m_Children[i]];
				if( abs(l_Res.m_RayOrigin.x - l_ChildBox.m_BoxCenter.x) - 0.5 * l_ChildBox.m_BoxSize.x <= EDGE_THREASHOLD &&
					abs(l_Res.m_RayOrigin.y - l_ChildBox.m_BoxCenter.y) - 0.5 * l_ChildBox.m_BoxSize.y <= EDGE_THREASHOLD &&
					abs(l_Res.m_RayOrigin.z - l_ChildBox.m_BoxCenter.z) - 0.5 * l_ChildBox.m_BoxSize.z <= EDGE_THREASHOLD )
				{
					l_Res.m_CurrBoxID = l_Box.m_Children[i];
					g_Result[a_ThreadID.x] = l_Res;
					return;
				}

				float l_Dist = intersectRayAABB(l_Res.m_RayOrigin, l_Res.m_RayDir, l_ChildBox.m_BoxCenter, l_ChildBox.m_BoxSize);
				if( l_Dist > 0 && l_Dist < l_Min )
				{
					l_Min = l_Dist;
					l_bFoundMinBox = true;
					l_Res.m_CurrBoxID = l_Box.m_Children[i];
				}
			}
			if( l_bFoundMinBox )
			{
				l_Res.m_RayOrigin += l_Min * l_Res.m_RayDir;
				g_Result[a_ThreadID.x] = l_Res;
				return;
			}
			else if( !l_bLeaf )
			{
				l_Res.m_StateDepth = l_Res.m_StateDepth & 0x000000ff;
				l_Res.m_StateDepth += LIGHTMAP_STATE_NEXTBOX;
				g_Result[a_ThreadID.x] = l_Res;
				return;
			}
			}break;

		case LIGHTMAP_STATE_NEXTBOX:{
			l_Box = g_Box[l_Res.m_CurrBoxID];

			float3 l_LengthSign = sign(l_Res.m_RayDir) * 0.5;
			float3 l_LengthVec = abs((l_Box.m_BoxCenter + l_LengthSign * l_Box.m_BoxSize - l_Res.m_RayOrigin) / l_Res.m_RayDir);
			int3 l_DirOffset = int3(ZP, ZP, ZP);
			if( abs(l_LengthVec.x - l_LengthVec.y) < EDGE_THREASHOLD && abs(l_LengthVec.x - l_LengthVec.z) < EDGE_THREASHOLD && abs(l_LengthVec.z - l_LengthVec.y) < EDGE_THREASHOLD )
			{
				l_DirOffset.x = l_LengthSign.x < 0.0 ? NP : PP;
				l_DirOffset.y = l_LengthSign.y < 0.0 ? NP : PP;
				l_DirOffset.z = l_LengthSign.z < 0.0 ? NP : PP;
			}
			else
			{
				l_Min = min(l_LengthVec.x, min(l_LengthVec.y, l_LengthVec.z));
				if( l_Min == l_LengthVec.x )
				{
					l_DirOffset.x = l_LengthSign.x < 0.0 ? NP : PP;
					if( abs(l_Min - l_LengthVec.y) < EDGE_THREASHOLD )		l_DirOffset.y = l_LengthSign.y < 0.0 ? NP : PP;
					else if( abs(l_Min - l_LengthVec.z) < EDGE_THREASHOLD )	l_DirOffset.z = l_LengthSign.z < 0.0 ? NP : PP;
				}
				else if( l_Min == l_LengthVec.y )
				{
					l_DirOffset.y = l_LengthSign.y < 0.0 ? NP : PP;
					if( abs(l_Min - l_LengthVec.x) < EDGE_THREASHOLD )		l_DirOffset.x = l_LengthSign.x < 0.0 ? NP : PP;
					else if( abs(l_Min - l_LengthVec.z) < EDGE_THREASHOLD )	l_DirOffset.z = l_LengthSign.z < 0.0 ? NP : PP;
				}
				else
				{
					l_DirOffset.z = l_LengthSign.z < 0.0 ? NP : PP;
					if( abs(l_Min - l_LengthVec.x) < EDGE_THREASHOLD )		l_DirOffset.x = l_LengthSign.x < 0.0 ? NP : PP;
					else if( abs(l_Min - l_LengthVec.y) < EDGE_THREASHOLD )	l_DirOffset.y = l_LengthSign.y < 0.0 ? NP : PP;
				}
			}

			l_Res.m_CurrBoxID = l_Box.m_Neighbor[NEIGHBOR_INDEX(l_DirOffset.x, l_DirOffset.y, l_DirOffset.z)];
			l_Res.m_RayOrigin += l_Min * l_Res.m_RayDir;
			l_Res.m_StateDepth = l_Res.m_StateDepth & 0x000000ff;
			l_Res.m_StateDepth += LIGHTMAP_STATE_CHILDBOX;
			g_Result[a_ThreadID.x] = l_Res;
			}return;

		//case LIGHTMAP_STATE_THROUGH:
		default:break;
	}

	float l_MinDist = FLT_MAX;
	int l_TargetTriangle = -1;
	for( int i=l_Box.m_TriangleRange.x ; i<l_Box.m_TriangleRange.y ; ++i )
	{
		if( l_Res.m_TriangleIdx == i ) continue;

		LightmapVertex l_Pos1 = g_Vertex[g_Indicies[i].x];
		LightmapVertex l_Pos2 = g_Vertex[g_Indicies[i].y];
		LightmapVertex l_Pos3 = g_Vertex[g_Indicies[i].z];

		float l_Dist = intersectRayTriangle(l_Res.m_RayOrigin, l_Res.m_RayDir, l_Pos1.m_Position, l_Pos2.m_Position, l_Pos3.m_Position);
		if( l_Dist >= 0.0 && l_Dist < l_MinDist )
		{
			l_MinDist = l_Dist;
			l_TargetTriangle = i;
		}
	}

	l_Res.m_StateDepth = l_Res.m_StateDepth & 0x000000ff;
	l_Res.m_RayOrigin += l_MinDist * l_Res.m_RayDir;
	if( -1 == l_TargetTriangle ) l_Res.m_StateDepth += LIGHTMAP_STATE_NEXTBOX;
	else
	{
		l_Res.m_StateDepth += LIGHTMAP_STATE_SCATTER;
		l_Res.m_TriangleIdx = l_TargetTriangle;
	}

	g_Result[a_ThreadID.x] = l_Res;
}