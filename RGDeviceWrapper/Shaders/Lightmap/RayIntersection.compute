#include <StdInclude.h>
#include "autoBinder.h"

#deifne LIGHTMAP_STATE_IDLE		0
#define LIGHTMAP_STATE_SCATTER	(1*256)
#define LIGHTMAP_STATE_THROUGH	(2*256)
#define LIGHTMAP_STATE_NEXTBOX	(3*256)
#define LIGHTMAP_STATE_TREADEND	(4*256)

[numthreads(16, 1, 1 )]
void main(uint3 a_ThreadID : SV_DispatchThreadID)
{
	LightmapIntersectResult l_Res = g_Result[a_ThreadID.x];
	LightmapBox l_Box = (LightmapBox)0;
	int l_MaxSampleCount = g_Triangles[0].w;
	switch( l_Res.m_StateDepth & 0xffffff00 )
	{
		case LIGHTMAP_STATE_IDLE:{
			int l_RayID = 0;
			InterlockedAdd(g_Triangles[0].y, 1, l_RayID);
			if( l_RayID >= l_MaxSampleCount )
			{
				int l_NextTarget = g_Triangles[0].x + 1;
				if( l_NextTarget > g_Triangles[0].z * 64 + 63 )
				{
					l_Res.m_StateDepth = LIGHTMAP_STATE_TREADEND;
					g_Result[a_ThreadID.x] = l_Res;
					InterlockedAdd(g_Triangles[0].w, -1);
					return;
				}

				l_RayID -= l_MaxSampleCount;
				l_Res.m_BoxHarmonicsID = l_NextTarget;
			}
			else l_Res.m_BoxHarmonicsID = g_Triangles[0].x;

			l_Res.m_StateDepth = l_Res.m_StateDepth & 0xffffff00;
			l_Res.m_Color = float3(1.0, 1.0, 1.0);
			l_Res.m_Emissive = float3(0.0, 0.0, 0.0);
			l_Res.m_TriangleIdx = -1;
			l_Res.m_CurrID = (l_Res.m_BoxHarmonicsID & 0xffc0) / 64;

			l_Box = g_Box[l_Res.m_CurrID];
			l_Res.m_RayOrigin = l_Box.m_BoxCenter;
			
			int3 l_BoxIdx;
			l_BoxIdx.x = l_Res.m_BoxHarmonicsID & 63;
			l_BoxIdx.z = l_BoxIdx.x / 16;
			l_BoxIdx.y = (l_BoxIdx.x / 4) % 4;
			l_BoxIdx.x = l_BoxIdx.x % 4;

			const float c_Sub[4] = {-0.375, -0.125, 0.125, 0.375};
			l_Res.m_RayOrigin += l_Box.m_BoxSize * float3(c_Sub[l_BoxIdx.x], c_Sub[l_BoxIdx.y], c_Sub[l_BoxIdx.z]);

			float l_Quad = sqrt(l_MaxSampleCount);
			float l_Phi = a_ThreadID.x / l_Quad;
			float l_Theta = floor(l_Phi) / l_Quad;
			l_Phi = frac(l_Phi);

			l_Theta = acos(1.0 - 2.0 * l_Theta);
			l_Phi = 2.0 * MATH_PI * l_Phi;

			l_Res.m_RayDir = normalize(float3(cos(l_Theta) * sin(l_Phi), cos(l_Theta) * cos(l_Phi), sin(l_Theta)));
			}break;

		case LIGHTMAP_STATE_TREADEND: return;

		case LIGHTMAP_STATE_NEXTBOX:{
			int l_CurrBox = l_Res.m_CurrBoxID;
			for( int i=0 ; i<g_Triangles[0].z ; ++i )
			{
				LightmapBox l_ThisBox = g_Box[l_CurrBox];
				
			}
			}break;

		//case LIGHTMAP_STATE_THROUGH:
		default:break;
	}

	float l_MinDist = FLT_MAX;
	int l_TargetTriangle = -1;
	for( int i=l_Box.m_TriangleRange.x ; i<l_Box.m_TriangleRange.y ; ++i )
	{
		if( l_Res.m_TriangleIdx == i ) continue;

		LightmapVertex l_Pos1 = g_Vertex[g_Triangles[i].x];
		LightmapVertex l_Pos2 = g_Vertex[g_Triangles[i].y];
		LightmapVertex l_Pos3 = g_Vertex[g_Triangles[i].z];

		float l_Dist = intersectRayTriangle(l_Res.m_RayOrigin, l_Res.m_RayDir, l_Pos1.m_Position, l_Pos2.m_Position, l_Pos3.m_Position);
		if( l_Dist >= 0.0 && l_Dist < l_MinDist )
		{
			l_MinDist = l_Dist;
			l_TargetTriangle = i;
		}
	}

	l_Res.m_StateDepth = l_Res.m_StateDepth & 0x000000ff;
	l_Res.m_RayOrigin += l_MinDist * l_Res.m_RayDir;
	if( -1 == l_TargetTriangle ) l_Res.m_StateDepth += LIGHTMAP_STATE_NEXTBOX;
	else
	{
		l_Res.m_StateDepth += LIGHTMAP_STATE_SCATTER;
		l_Res.m_TriangleIdx = l_TargetTriangle;
	}

	g_Result[a_ThreadID.x] = l_Res;
}